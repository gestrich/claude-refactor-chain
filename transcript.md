Test. All right, so I want to talk through an idea I have, which I think might be something cool. I'm not sure. So the background is, um, kind of the headline of what I'm trying to do. is refactor your code in the, um, in an automated way using AI. And what I think I want to do is I want to call this something like a pull request chain. And What a poor request chain may be. is say, um, so a little background. Like, you can use AI to refactor your code. A couple challenges that. to that. If you have a large code base, you would do a lottery factoring. is going to take you a lot of time to both stage those poor requests to review those poor requests. And you constantly need motivation to keep staging a couple things. You, it's, How do I put this? When it comes to refactoring, what's going to convince you to remember to keep creating these poor requests on a regular basis? Like it almost becomes like a maintenance burden where, you know, say every day you need to create a poor request. It's just like a lot of work. Um, so I think I want to say, like in in this project. I'm doing, one of the background is like, keeping the motivation to keep creating pool request over and over again, it'd be nice if it were more automated and you could be a little more hands off, something to remind you basically. to keep that going or something to at least break the inertia on it. That's number one. Say, the other thing is, um, You, it's good to have a sense of progress. Um, if possible. So a sense of, um, you know, a way to kind of measure. Another maybe, um, Um, one of the other challenges is the burden of review. Um, Just saying so, yeah, it takes a long time to review Eastport request. So Juan, what's going to keep you motivated? What, you know, in terms of this burden of review issue. Um, how can you ease that? Um, how can you watch progress if you have like one of these really long refactors that's going to take a ton of time? Is there a way to make this a little more automatic where you say up front? Like, I want to refactor my application. I have all these things going on, you know, help me to, um, kind of, yeah. So that's kind of. So that's kind of the background. On some of the aims, the problems that I'm trying to solve. And thinking through, like, what I could deliver, I think that would be useful. I had this idea of what I'll call the refactor chain. Or maybe the continuous, continuous refactoring. And, um, The way I could imagine that working is, one, you define your plan in your code base. So in your code base, you know, you have a directory or something, which is the, um, the plan for the refactor. And ideally, you have a way to be able to break that up into smaller phases. So let's say, for instance, I want to repacker all my view controllers. to, you know, I don't know, let me think it through. I want all my view controllers to, um, Let's say. I don't even know what it would be. But I just want to refactor all my view controllers too. Um, I'm not even sure. I have to think it through. Um, but let's say I want to reap, I want to think of another thing. No, I'm not even sure. So, let's just say, I have some project. I wanna, um, Just make it a complex thing. I've, um, objective C, and I want to convert it to Swift to... Swift. Um, one way to kind of count that is by the number of Swift, objective C files that I have. So, kind of is the 1st step, could be kind of to take an audit. And, or one of the earlier steps would be to take an audit and help to track this stuff. So you could take, say, code base and say, all right, I have 300 objective C files, and I want to convert each one to Swift. And you could have, you know, AI, you know, you write a little bash script or something in order to create a markdown document that has a list of each of those things that you want to complete. So once you do that, then you need to create a really strong... Um, set of rules. for how you're going to do that. So, um, you know, and again, you could use AI to help create examples and different things and, um, You know, could, uh, yeah, create a specification that says, here is how we do this stuff. Um, You could also use Claude code as a feature called Tools, T-O-O-L-S. You could define those to explain a more depth how to do different pieces of the refactors. So I kind of want to put a little note on that. That might be something that I want to explore. But it's about creating this well-defined specification on how to refactor your code base. So you create the specification. You commit it to your code base. Um, and then, uh, yeah, so you have these, um, so list of things that you need to do and you have, you know, such you have, um, a list of rules. You kind of took a stab at that. Say, this is just where it begins. Like, if you think you're going to let this thing loose on your code base, you're going to have it refact your overlap, you're going to be sorely disappointed. So one of the things I want to introduce is what I call the refactor chain. And what that is, is you have this list of tasks that you want to do. Each, um, you kick it off by uh, you know, it's like a GitHub action. basically, I think. There's a GitHub action. And that action is on a Either a timer, and maybe each day it checks to see if there's any open poll request already for that type of refactor. And, um, what it does. Is it, um, if there are none that are open? It creates a poor request. And it bases it off of the main branch, and then it runs on as a GitHub action, it runs clawed code, grabbing the next available thing that it needs to do. It runs that refactor on the code base and it stages a port request and then you'll get a notification for it. It's actually very simple. Then your the rule switches back to you. You're going to get a notification saying that this refactor is available for you just as if a developer had created it. No, there's a couple things that could happen. One, you may look at the poor request, and depending on the complexity and the level of unit test, you may just be able to sign off and say, this is good enough. This, whatever the refactor I did is so simple, I could tell it builds my test build. I don't need to go any deeper and just hit the merge button. You may find on the contrary that you need to do some manual testing because you don't have good test coverage. Um, it's a risky refactor. Who knows? But that's up to you to decide what you do there. And for the AI skeptics say like AI produces bad code and stuff, throw it away. Like, don't use it. Like, you do, you, you just look at it and think of it just an idea. But what I would challenge you to do is when you, this is where, I don't know, we'll call this, but this is like the refinement stage. And I'll call this, when you see how the re, check how your AI performed. What kind of job did it do? Did it do a good job? And then employ some tricks to improve your prompting. to keep making it better. See, the idea here is it's not about you trusting the AI to do the a good refactor for you based on what comes off the shelf and a model from class. No, you gotta assume that it doesn't know what to do. Assume it's going to mess everything up. It doesn't know your practices, your principles. It doesn't know your context, all those kinds of things. You have to give that to the AI. That's your that's your role. Each time you're seeing it mess up, you have to kind of pokes the AI into doing what you need it to do. So you're kind of going through this incremental process where you're both, you're reviewing the AI's output in the poll request, both to get that code change into the repo, but you're also going to your, um, your prompts and the knowledge base and stuff so that you can make it a little bit better for the next iteration. And with the goal of getting to the point maybe, if you're lucky, where it could produce, you know, 90 some percent accuracy where you don't have to do much of anything at all. You're just hitting the merge button or doing your quality checks or whatever it may be, but you really get it fine tuned in knowing how to, um, you know, perform these refactors. So the idea, though, is like, you know, you're you're continually, you're getting, you're only getting one poll request at a time. So as part of this, what I'm calling the refactor chain. You only have one at a time. So you're not scattering. it very clear what you need to do next. You can work on it in your own time. You could take a day, you could take a couple days, you could do one a week. It's really up to you and how many of these refactors you want to get going. You got a couple different kinds of refactors going at the same time. You can choose to, um, create multiple um, open poor requests at the same time. Oh, it's really up to you. Um, so yeah, that's um, that's the general idea. So, um, Yeah, so this kind of gives me a whole opportunity to create these refactor chains. So, What I'm thinking about doing here. So that's the background on kind of, I think, what I want to explore motivations and like what, where I'm thinking about taking this. I think what I want to show, like maybe a good way to approach this is I have my own code basis, my own, um, repositories that are open source. I was thinking about The fighting a few refactors and just going through it, piece by piece here, and seeing if I can, um, you know, do this myself. Um, and I need to figure out some problems, like, you know, running cloud code on, as a GitHub action. I already have some experience there, but I need to work on that. I need to work on, um, things like, uh, Some tooling to figure out. Um, to figure out what, you know, what pool request to stage next. That's another thing I need to do. I think I want to keep it really simple. I think I hate to say this, but it's probably got to be a bash script. Um, I want to resist temptation to lock myself down to using Swift for this. As much as, you know, I like that. That's not gonna farewell for, like, a blog or something that I share open source. I think bash would really be best for that. Um. I need to figure out things like managing the clawed token, access, whether to use my own action versus to use the out of the box clawed code action. Um, Things like. Running this as like on a timer or something. Um, yeah, I want to keep it really simple. I think would be my goal. Um, so I think the goal would be really to come out with like a video where I walk through how to do this, maybe a blog post on how to do this. But then more importantly, for my work, make it so that we can use this. Um, Yeah, make this actually a usable thing. And I think. The benefit to doing this is like my company is very interested in AI. I'm involved in this iOS 16 kind of refactor project. It would be wonderful to have like, particularly for this project. identifying some simple, you know, just that we could start doing to, to start merging, some of this code. Um, so, you know, slowly.
