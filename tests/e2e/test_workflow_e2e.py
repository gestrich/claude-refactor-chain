"""End-to-End tests for ClaudeStep workflow.

This module contains E2E integration tests that verify the ClaudeStep workflow
creates PRs correctly, generates AI summaries, includes cost information, and
handles edge cases like empty specs.

The tests use a recursive workflow pattern where the claude-step repository
tests itself by triggering the claudestep.yml workflow.

Note: These tests have been optimized to reduce redundant workflow executions.
The main workflow test (test_basic_workflow_end_to_end) validates PR creation,
AI summaries, and cost information in a single test run.

TESTS IN THIS MODULE:

1. test_basic_workflow_end_to_end
   - What: Verifies complete workflow execution (spec â†’ PR with summary + cost)
   - Why E2E: Tests integration of all workflow steps and GitHub API interactions

2. test_reviewer_capacity_limits
   - What: Verifies reviewer maxOpenPRs capacity enforcement across multiple runs
   - Why E2E: Tests integration between reviewer management and PR creation

3. test_auto_start_workflow
   - What: Verifies pushing spec to main-e2e triggers auto-start workflow and PR creation
   - Why E2E: Tests real user flow of auto-start and automatic PR generation

4. test_merge_triggered_workflow
   - What: Verifies merging a PR triggers creation of the next PR
   - Why E2E: Tests GitHub Actions trigger-on-merge integration
"""

import pytest

from .helpers.github_helper import GitHubHelper


def test_basic_workflow_end_to_end(
    gh: GitHubHelper,
    test_project: str
) -> None:
    """Test complete ClaudeStep workflow: spec â†’ PR with summary and cost info.

    This consolidated test verifies the entire E2E workflow by:
    1. Using the permanent e2e-test-project from main branch
    2. Triggering the claudestep.yml workflow on e2e-test branch
    3. Waiting for workflow completion
    4. Verifying a PR was created with expected content
    5. Verifying the PR has an AI-generated summary comment
    6. Verifying the PR has cost/usage information

    Note: Cleanup happens at test START (not end) to allow manual inspection.

    Args:
        gh: GitHub helper fixture
        test_project: Test project name from fixture (e2e-test-project)
    """
    # Trigger the claudestep-test workflow
    # The workflow will fetch specs from main branch via GitHub API
    gh.trigger_workflow(
        workflow_name="claudestep.yml",
        inputs={"project_name": test_project},
        ref="e2e-test"
    )

    # Wait for workflow to start
    gh.wait_for_workflow_to_start(
        workflow_name="claudestep.yml",
        timeout=30,
        branch="e2e-test"
    )

    # Wait for workflow to complete
    workflow_run = gh.wait_for_workflow_completion(
        workflow_name="claudestep.yml",
        timeout=900  # 15 minutes
    )

    run_url = workflow_run.url
    assert workflow_run.conclusion == "success", \
        f"Workflow should complete successfully. Run URL: {run_url}"

    # Get all PRs for this project (workflow now uses hash-based branch names)
    project_prs = gh.get_pull_requests_for_project(test_project)

    assert len(project_prs) > 0, \
        f"At least one PR should be created for project '{test_project}'. Workflow run: {run_url}"

    # Get the first (most recent) PR
    pr = project_prs[0]
    branch_name = pr.head_ref_name
    pr_url = f"https://github.com/gestrich/claude-step/pull/{pr.number}"

    assert pr.state == "open", \
        f"PR #{pr.number} should be open but is {pr.state}. PR URL: {pr_url}"

    # Verify PR has a title
    assert pr.title, f"PR #{pr.number} should have a title. PR URL: {pr_url}"

    # Get PR comments for summary and cost verification
    comments = gh.get_pr_comments(pr.number)

    # Verify there's at least one comment
    assert len(comments) > 0, \
        f"PR #{pr.number} should have at least one comment. PR URL: {pr_url}"

    # Extract comment bodies for analysis
    comment_bodies = [c.body for c in comments]

    # Verify PR has a single combined comment with both summary and cost breakdown
    # The combined comment should contain:
    # 1. AI-Generated Summary header
    # 2. Cost Breakdown section (with "ðŸ’° Cost Breakdown" header)
    # 3. ClaudeStep footer
    has_combined_comment = any(
        "## AI-Generated Summary" in body and "## ðŸ’° Cost Breakdown" in body
        for body in comment_bodies
    )
    assert has_combined_comment, \
        f"PR #{pr.number} should have a combined comment with both '## AI-Generated Summary' and '## ðŸ’° Cost Breakdown' headers. " \
        f"Found {len(comments)} comment(s). PR URL: {pr_url}"

    # Verify the combined comment has the ClaudeStep footer
    has_claudestep_footer = any(
        "Generated by ClaudeStep" in body and "View workflow run" in body
        for body in comment_bodies
    )
    assert has_claudestep_footer, \
        f"PR #{pr.number} combined comment should have ClaudeStep footer. " \
        f"Found {len(comments)} comment(s). PR URL: {pr_url}"

    # Verify costs are non-zero (validates execution file parsing works correctly)
    import re
    for body in comment_bodies:
        if "## ðŸ’° Cost Breakdown" in body:
            # Extract cost values from the table
            # Pattern matches lines like: | Main refactoring task | $0.123456 |
            cost_pattern = r'\|\s*(?:Main refactoring task|PR summary generation)\s*\|\s*\$(\d+\.\d+)\s*\|'
            matches = re.findall(cost_pattern, body)

            if matches:
                costs = [float(m) for m in matches]
                # Main refactoring task cost should never be zero
                assert len(costs) >= 1, \
                    f"Cost breakdown should have at least one cost value. PR URL: {pr_url}"
                assert costs[0] > 0, \
                    f"Main refactoring task cost should be non-zero, got ${costs[0]}. " \
                    f"This indicates execution file parsing failed. PR URL: {pr_url}"
                # If there's a summary cost, it should also be non-zero (when summary generation runs)
                if len(costs) >= 2 and "PR summary generation" in body:
                    assert costs[1] > 0, \
                        f"PR summary generation cost should be non-zero when summary is generated, got ${costs[1]}. " \
                        f"This indicates execution file parsing failed. PR URL: {pr_url}"
                break
    else:
        # If we didn't find cost breakdown, fail the test
        assert False, f"Could not find cost breakdown in PR #{pr.number} comments. PR URL: {pr_url}"


def test_reviewer_capacity_limits(
    gh: GitHubHelper,
    test_project: str
) -> None:
    """Test that ClaudeStep respects reviewer capacity limits.

    This test uses the permanent e2e-test-project (which has 300+ tasks and
    a reviewer capacity limit configured) and verifies that:
    1. The workflow creates PRs up to the capacity limit
    2. The workflow skips PR creation when reviewer is at capacity

    Note: Each workflow run creates ONE PR. The workflow must be triggered
    multiple times to create multiple PRs up to the capacity limit.

    With the new spec-file-source-of-truth design, the test project exists
    permanently in the main branch with pre-configured capacity limits.

    Cleanup happens at test START (not end) to allow manual inspection.

    Args:
        gh: GitHub helper fixture
        test_project: Test project name from fixture (e2e-test-project)
    """
    # The permanent e2e-test-project has maxOpenPRs: 5 configured
    # We'll test that capacity limits are respected

    try:
        # === First workflow run: should create PR for first task ===
        gh.trigger_workflow(
            workflow_name="claudestep.yml",
            inputs={"project_name": test_project},
            ref="e2e-test"
        )
        gh.wait_for_workflow_to_start(workflow_name="claudestep.yml", timeout=30, branch="e2e-test")
        workflow_run_1 = gh.wait_for_workflow_completion(
            workflow_name="claudestep.yml",
            timeout=900  # 15 minutes - increased to accommodate AI inference and GitHub operations
        )
        run_url_1 = workflow_run_1.url
        assert workflow_run_1.conclusion == "success", \
            f"First workflow run should succeed. Run URL: {run_url_1}"

        # Get PRs after first workflow run
        prs_after_first = gh.get_pull_requests_for_project(test_project)
        assert len(prs_after_first) >= 1, \
            f"First PR should be created. Workflow run: {run_url_1}"

        # === Second workflow run: should create PR for second task ===
        gh.trigger_workflow(
            workflow_name="claudestep.yml",
            inputs={"project_name": test_project},
            ref="e2e-test"
        )
        gh.wait_for_workflow_to_start(workflow_name="claudestep.yml", timeout=30, branch="e2e-test")
        workflow_run_2 = gh.wait_for_workflow_completion(
            workflow_name="claudestep.yml",
            timeout=900  # 15 minutes - increased to accommodate AI inference and GitHub operations
        )
        run_url_2 = workflow_run_2.url
        assert workflow_run_2.conclusion == "success", \
            f"Second workflow run should succeed. Run URL: {run_url_2}"

        # Get PRs after second workflow run
        prs_after_second = gh.get_pull_requests_for_project(test_project)
        assert len(prs_after_second) >= 2, \
            f"Second PR should be created. Workflow run: {run_url_2}"

        # Verify at least 2 PRs were created successfully
        assert len(prs_after_second) >= 2, \
            f"Expected at least 2 PRs to be created. " \
            f"Workflow runs: [1] {run_url_1}, [2] {run_url_2}"

    except Exception as e:
        raise e


def test_auto_start_workflow(
    gh: GitHubHelper,
    setup_test_project: str
) -> None:
    """Test that auto-start workflow triggers when spec is pushed to main-e2e.

    This test validates the real user flow where pushing a spec to main-e2e
    automatically triggers PR creation via the auto-start workflow.

    The test verifies:
    1. Pushing spec to main-e2e triggers claudestep-auto-start.yml workflow
    2. Auto-start workflow completes successfully
    3. Auto-start triggers the main claudestep.yml workflow
    4. Main workflow creates a PR for the first task
    5. PR has "claudestep" label
    6. PR targets main-e2e branch
    7. PR has AI summary comment with cost breakdown

    Cleanup happens at test START (not end) to allow manual inspection.

    Args:
        gh: GitHub helper fixture
        setup_test_project: Test project created and pushed to main-e2e
    """
    from claudestep.domain.constants import DEFAULT_PR_LABEL
    from ..constants import E2E_TEST_BRANCH

    test_project = setup_test_project

    # Wait for auto-start workflow to start
    gh.wait_for_workflow_to_start(
        workflow_name="claudestep-auto-start.yml",
        timeout=60,
        branch=E2E_TEST_BRANCH
    )

    # Wait for auto-start workflow to complete
    auto_start_run = gh.wait_for_workflow_completion(
        workflow_name="claudestep-auto-start.yml",
        timeout=300,  # 5 minutes
        branch=E2E_TEST_BRANCH
    )

    assert auto_start_run.conclusion == "success", \
        f"Auto-start workflow should complete successfully. Run URL: {auto_start_run.url}"

    # Wait for main claudestep workflow to start (triggered by auto-start)
    gh.wait_for_workflow_to_start(
        workflow_name="claudestep.yml",
        timeout=60,
        branch=E2E_TEST_BRANCH
    )

    # Wait for main workflow to complete
    main_run = gh.wait_for_workflow_completion(
        workflow_name="claudestep.yml",
        timeout=900,  # 15 minutes
        branch=E2E_TEST_BRANCH
    )

    assert main_run.conclusion == "success", \
        f"Main workflow should complete successfully. Run URL: {main_run.url}"

    # Get all PRs for this project
    project_prs = gh.get_pull_requests_for_project(test_project)

    assert len(project_prs) > 0, \
        f"At least one PR should be created for project '{test_project}'. Workflow run: {main_run.url}"

    # Get the first (most recent) PR
    pr = project_prs[0]
    pr_url = f"https://github.com/gestrich/claude-step/pull/{pr.number}"

    # Verify PR is open
    assert pr.state == "open", \
        f"PR #{pr.number} should be open but is {pr.state}. PR URL: {pr_url}"

    # Verify PR has claudestep label
    assert DEFAULT_PR_LABEL in [label.lower() for label in pr.labels], \
        f"PR #{pr.number} should have '{DEFAULT_PR_LABEL}' label. PR URL: {pr_url}"

    # Verify PR targets main-e2e branch
    assert pr.base_ref_name == E2E_TEST_BRANCH, \
        f"PR #{pr.number} should target '{E2E_TEST_BRANCH}' branch but targets '{pr.base_ref_name}'. PR URL: {pr_url}"

    # Verify PR has a title
    assert pr.title, f"PR #{pr.number} should have a title. PR URL: {pr_url}"

    # Get PR comments for summary and cost verification
    comments = gh.get_pr_comments(pr.number)

    # Verify there's at least one comment
    assert len(comments) > 0, \
        f"PR #{pr.number} should have at least one comment. PR URL: {pr_url}"

    # Extract comment bodies for analysis
    comment_bodies = [c.body for c in comments]

    # Verify PR has a combined comment with both summary and cost breakdown
    has_combined_comment = any(
        "## AI-Generated Summary" in body and "## ðŸ’° Cost Breakdown" in body
        for body in comment_bodies
    )
    assert has_combined_comment, \
        f"PR #{pr.number} should have a combined comment with both '## AI-Generated Summary' and '## ðŸ’° Cost Breakdown' headers. " \
        f"Found {len(comments)} comment(s). PR URL: {pr_url}"


def test_merge_triggered_workflow(
    gh: GitHubHelper,
    setup_test_project: str
) -> None:
    """Test that merging a PR triggers creation of the next PR.

    This test verifies that when a ClaudeStep PR is merged, the workflow
    automatically triggers and creates a PR for the next task in the spec.

    The test verifies:
    1. Auto-start workflow creates first PR (reuses test_auto_start_workflow setup)
    2. Merging the first PR triggers claudestep.yml workflow via PR close event
    3. Workflow creates a second PR for the next task
    4. Second PR has "claudestep" label
    5. Second PR targets main-e2e branch

    Cleanup happens at test START (not end) to allow manual inspection.

    Args:
        gh: GitHub helper fixture
        setup_test_project: Test project created and pushed to main-e2e (has 3 tasks)
    """
    from claudestep.domain.constants import DEFAULT_PR_LABEL
    from ..constants import E2E_TEST_BRANCH

    test_project = setup_test_project

    # Wait for auto-start workflow to complete (from test setup)
    gh.wait_for_workflow_to_start(
        workflow_name="claudestep-auto-start.yml",
        timeout=60,
        branch=E2E_TEST_BRANCH
    )

    auto_start_run = gh.wait_for_workflow_completion(
        workflow_name="claudestep-auto-start.yml",
        timeout=300,  # 5 minutes
        branch=E2E_TEST_BRANCH
    )

    assert auto_start_run.conclusion == "success", \
        f"Auto-start workflow should complete successfully. Run URL: {auto_start_run.url}"

    # Wait for main workflow to complete (creates first PR)
    gh.wait_for_workflow_to_start(
        workflow_name="claudestep.yml",
        timeout=60,
        branch=E2E_TEST_BRANCH
    )

    first_workflow_run = gh.wait_for_workflow_completion(
        workflow_name="claudestep.yml",
        timeout=900,  # 15 minutes
        branch=E2E_TEST_BRANCH
    )

    assert first_workflow_run.conclusion == "success", \
        f"First workflow run should complete successfully. Run URL: {first_workflow_run.url}"

    # Get the first PR that was created
    project_prs = gh.get_pull_requests_for_project(test_project)
    assert len(project_prs) > 0, \
        f"At least one PR should be created for project '{test_project}'. Workflow run: {first_workflow_run.url}"

    first_pr = project_prs[0]
    first_pr_url = f"https://github.com/gestrich/claude-step/pull/{first_pr.number}"

    # Verify first PR is open
    assert first_pr.state == "open", \
        f"First PR #{first_pr.number} should be open. PR URL: {first_pr_url}"

    # Merge the first PR (this should trigger the workflow via PR close event)
    gh.merge_pull_request(first_pr.number)

    # Wait for the workflow to be triggered by the PR merge
    gh.wait_for_workflow_to_start(
        workflow_name="claudestep.yml",
        timeout=60,
        branch=E2E_TEST_BRANCH
    )

    # Wait for the second workflow run to complete (creates second PR)
    second_workflow_run = gh.wait_for_workflow_completion(
        workflow_name="claudestep.yml",
        timeout=900,  # 15 minutes
        branch=E2E_TEST_BRANCH
    )

    assert second_workflow_run.conclusion == "success", \
        f"Second workflow run should complete successfully. Run URL: {second_workflow_run.url}"

    # Get all PRs for this project again
    project_prs = gh.get_pull_requests_for_project(test_project)

    # We should now have 2 PRs: first one (merged) and second one (open)
    assert len(project_prs) >= 2, \
        f"At least 2 PRs should exist for project '{test_project}' after merge. " \
        f"Found {len(project_prs)} PR(s). Second workflow run: {second_workflow_run.url}"

    # Find the second PR (should be open, not the merged one)
    open_prs = [pr for pr in project_prs if pr.state == "open"]
    assert len(open_prs) > 0, \
        f"At least one open PR should exist after merging first PR. " \
        f"Found {len(open_prs)} open PR(s). Second workflow run: {second_workflow_run.url}"

    second_pr = open_prs[0]
    second_pr_url = f"https://github.com/gestrich/claude-step/pull/{second_pr.number}"

    # Verify second PR has claudestep label
    assert DEFAULT_PR_LABEL in [label.lower() for label in second_pr.labels], \
        f"Second PR #{second_pr.number} should have '{DEFAULT_PR_LABEL}' label. PR URL: {second_pr_url}"

    # Verify second PR targets main-e2e branch
    assert second_pr.base_ref_name == E2E_TEST_BRANCH, \
        f"Second PR #{second_pr.number} should target '{E2E_TEST_BRANCH}' branch but targets '{second_pr.base_ref_name}'. " \
        f"PR URL: {second_pr_url}"

    # Verify second PR is different from first PR
    assert second_pr.number != first_pr.number, \
        f"Second PR should be different from first PR. Both have number {first_pr.number}"